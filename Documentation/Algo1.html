<title>Tidy Drawing Trees - Algorithm 1</title>
<head><h1>Algorithm 1 (Naive Tree Drawer)</h1></head>

<body>
<p>This algorithm provides a naive method of drawing n-ary trees. 
The algorithm is based on two constraints:</p>
<ol>
<li>All nodes of same height must lie on a straight line and this line must be parallel to the lines
    generated by nodes of other levels.</li>
<li>The tree must occupy minimum width. This is accomplished by left justifying all the nodes.</li>
</ol>

<b>Methodology</b>

<ul>
<li>The tree structure is provided as input and max height is calculated. the buildTree() method populates the tree data structure.</li>
<li>The left-most position available for each level (called next_x) is also maintained. Initially we set x=1 for all levels</li>
<li>During tree traversal, at a given node, the left most available position at that level is assigned to that node. This process is iterated over all nodes.</li>
<li>The positions of each node are stored in the tree data structure.</li>
<li>Once this vector is created, the drawTree() method draws circles and lines using the coordinates of the nodes.</li>
</ul>

<b>Sample Output</b>
<br></br>
<img src="Algo1good.png" align="middle"></img>
<br></br>

<b>Analysis</b>
<p>As the description suggests, this is a naive tree drawer and will not perform well for complex trees. </p>
<p>In the case below, clearly we notice a lot of congestion around the central two levels due to the relatively large number of nodes present on that level. The congestion could be reduced by <b>increasing the spacing between nodes</b> however this would increase the tree width by a large amount, does graphically violating one of our target aesthetics.
</p>
<p>
The assignment of coordinates is done by a modification of <b>Morris Traversal</b> which does not require recursion or a stack. This is achieved by keeping a status flag associated with each node, updated on successive visits.
The Morris traversal first visits a node, and then its children. When there are no children nodes, it reverts to the parent. If there is no parent, our algorithm terminates. Thus, we traverse the tree twice making our traversal complexity <b>&Theta;(n).</b>
</p>
<img src="Algo1badcase.png" align="middle"></img>
<br></br>
</body>
